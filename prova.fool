let
  
  class A (x:int, y:int) {
	fun getX:int() x;
  	fun getY:int() y;
  }

  fun f:int(x:A, rel:(A)->bool) 
  	if(rel(x))
  	 then {x.getX()}
	 else {x.getY()};

  fun r:bool(x:A)
  	if(x.getX() == x.getY())
  	 then {true}
  	 else {false};

  fun make:A(a:A)
  	if(a == null)
  	 then {new A(1,1)}	
	 else {a};
	 
var x:A = null;

in
	print(f(make(x),r));
/* SERBATOIO ESEMPI
let

  class List (f:int, r:List) {
    fun first:int() f;
    fun rest:List() r; 
  }
  
  fun printList:List (l:List) 
      let  
        fun makeList:List (l:List, i:int) new List (i,l);
      in 
         if (l == null) 
           then {null}
           else {makeList(printList(l.rest()),print(l.first()))};                 
  
  fun append:List (l1:List, l2:List)
      if (l1 == null)
        then {l2}
        else {new List(l1.first(), append(l1.rest(),l2))} ;  
    
  fun filter:List (l:List, accept:(int)->bool) 
      if (l == null) 
        then {null}
        else {if ( accept(l.first()) )
                then { new List( l.first(), filter(l.rest(),accept) ) }
                else { filter(l.rest(),accept) }
             };
         
  fun quicksort:List (l:List, rel:(int,int)->bool)    
      let
        var pivot:int = if (l==null) then {0} else {l.first()};       
        fun beforePivot:bool (x:int) rel(x,pivot);
        fun afterPivot:bool (x:int) !(rel(x,pivot));
      in        
         if (l == null) 
           then {null}
           else {append( 
                   quicksort( filter(l.rest(),beforePivot), rel ),                  
                   new List(  pivot,  quicksort( filter(l.rest(),afterPivot), rel )  )                       
                 )};
                                   
  fun inc:bool (x:int,y:int) x<=y;
  fun dec:bool (x:int,y:int) x>=y;
               
  var l:List = new List (2, 
                    new List(1,
                        new List(4,
                            new List (3, 
                                new List(2,
                                    new List(5,null))))));
  
in printList(quicksort(l,inc));



//Higher Order ( WORKS )
let
	fun g:int(x:(int,int)->int)
		x(5,7);
	fun f:int(c:int)
		let
			fun linsum:int(a:int,b:int)
				(a+b)*c;
		in
			g(linsum);
in
print(f(2));


----------------------------

//Object Orieted ( WORKS )

let

  class Account (money:int) {
    fun getMon:int () money;
  }
  
  class TradingAcc extends Account (invested:int) {
    fun getInv:int () invested;
  }
  
  class BankLoan (loan: Account) {
    fun getLoan:Account () loan;
    fun openLoan:Account (m:TradingAcc) if ((m.getMon()+m.getInv())>=30000) 
      then {new Account(loan.getMon())} 
      else {null};
  } 
  
  class MyBankLoan extends BankLoan (loan: TradingAcc) {
    fun openLoan:TradingAcc (l:Account) if (l.getMon()>=20000) 
      then {new TradingAcc(loan.getMon(),loan.getInv())} 
      else {null};
  } 
    
  var bl:BankLoan = new MyBankLoan(new TradingAcc(50000,40000));
  var myTradingAcc:TradingAcc = new TradingAcc(20000,5000);
  var myLoan:Account = bl.openLoan(myTradingAcc);
      
in print(if (myLoan==null) then {0} else {myLoan.getMon()});  
---------------------------
//WORKS
let 
  var x:int = 1;
  var b:bool = true;
in
  print (if (b) then { x+1 } else { x+2 });
---------------
//WORKS
let 
  fun f:int (i:int, j:int) i+j;
in
  print (f(3,5));
----------------
//WORKS
let
  var y:int = 5+2;
  fun f:bool (n:int, m:int)
    let 
      var x:int = m;
  in x==y;   
in  
  print ( 
    if f(y,8) 
      then { false }
      else { 10 }
  ); 
-----------------
//WORKS
let
	fun g:int(x:(int,int)->int)
		x(5,7);
	fun f:int(c:int)
	let
		fun linsum:int(a:int,b:int)
			(a+b)*c;
		in
			g(linsum);
in
	print(f(2));
  
-------------------------------------------

//WORKS
let
  class A () {
    fun getFucked:int() 1;
  }
  
  class B extends A() {
    fun getFucked:int() 2;
  }
  
  class C extends A() {
    fun getFucked:int() 3;
  }
	
  class D extends B() {
    fun getFucked:int() 4;
  }
  
  class E extends D() {
    fun getFucked:int() 5;
  }
  
  class F extends C() {
    fun getFucked:int() 6;
  }
  
  class G extends D() {
    fun getFucked:int() 7;
  }
  
  class Z() {
    fun getFucked:int() 8;
  }

  var a7:A = new A();
  var a8:A = new A();
  var f9:F = new F();
  var e10:E = new E();
  var g11:G = new G();
  
  var d12:E = if (true) then {e10} else {null};
-----------------------------------------------------
//WORKS (3)
let
  class A (f:int, b:bool) {
    fun first:int() f;
    fun second:bool() b; 
  }
  class B (f:int, b:bool) {
    fun first:int() f;
    fun second:bool() b; 
  }
  
  class C extends A (c:int){
	fun C:int() 8;
	fun D:bool() true;
  }
  
  var s:C = new C(1,true,2);
  var t:A = new C(3,false,4);
  
  var y:int = 5+2;
  fun f:bool (n:int, m:int)
    let 
      var x:int = m;
  in x==y;   
in  
  print ( 
    if f(y,s.first()) 
      then { s.second()	}
      else { t.first() }
  );
-----------------------------------
//WORKS (1 - True)
let
  class A (f:int, b:bool) {
    fun first:int() f;
    fun second:bool() b; 
  }
  class B (f:int, b:bool) {
    fun first:int() f;
    fun second:bool() b; 
  }
  
  var s:A = new A(3,true);
  var t:B = new B(4,false);
  
  var y:int = 5+2;
  fun f:bool (n:int, m:int)
    let 
      var x:int = m;
  in x==y;   
in  
  print ( 
    if f(s.first(),y) 
      then { s.second()	 }
      else { t.first() }
  );  
-------------------------------------
//WORKS (Typecheck AND, OR, NOT)
let
  var t:bool = true;
  var f:bool = false;
  var tAndf:bool = t && f;
  var fAndt:bool = f && t;
  var fAndf:bool = f && f;
  var tOrt:bool = t || t;  
  var tOrf:bool = t || f;  
  var fOrt:bool = f || t;  
  var fOrf:bool = f || t;  
  var notfAndf:bool = !(f) && f;
  var notfOrNotf:bool = !(f) || !(f);
  
in
  print (notfAndf);  
-----------------------------
WORKS (Recursion)
let
	fun f:int(x:int)
		if(x==0) then {0}
		else { print(f(x - 1)); }

in
	print(f(3));
------------------------
//WORKS (Typecheck/CodeGen Lesser/Greater Equal)
let
  var t:bool = true;
  var f:bool = false;
  var gEq:bool = 23 >= 10;
  var gEqNot:bool = 21 >= 23;
  var lEq:bool = 23 <= 24;
  var lEqNot:bool = 25 <= 24;
in
  print (lEqNot);  
-------------------------------
//WORKS (Typecheck/CodeGen Mult/Div/Minus)
let
  var t:bool = true;
  var f:bool = false;
  var mult2:int = 3 * 12;
  var mult3:int = 3 * 4 * 5;
  var div2:int = 3 / 2;
  var div2Bis:int = 4/2;
  var div3:int = 24 / 2 / 3;
  var minus2:int = 2 - 5;
  var minus3:int = 3 - 5 - 7;
  var minus2Bis:int = 6 - 1;
  var minus3Bis:int = minus2 - minus3;
in
  print (minus3Bis);  
----------------------------------------
//WORKS (HO + OOP)

 let
  
  class A (x:int, y:int) {
	fun getX:int() x;
  	fun getY:int() y;
  }

  fun f:int(x:A, rel:(A)->bool) 
  	if(rel(x))
  	 then {x.getX()}
	 else {x.getY()};

  fun r:bool(x:A)
  	if(x.getX() == x.getY())
  	 then {true}
  	 else {false};

  fun make:A(a:A)
  	if(a == null)
  	 then {new A(1,1)}	
	 else {a};
	 
var x:A = null;

in
	print(f(make(x),r));
--------------------------------------
//WORKS (HO + OOP) + Nested declarations

let 
  var x:int = 3;
  var y:int = 0;
  
  fun a:int ()
  	let
  		var z:int = x;
  		fun b:int (x:int) x+1;
  	in
  		x+b(1);
 
  
  fun g:int (f1:()->int, f2:(int,int)->int, x:int, y:int)
  	if f2(f1(),x+y) >= 10
      then { true }
      else { false };
      
  fun l:int (x:int, y:int) x+y;
  
in
	print(g(a,l,x,y));
*/